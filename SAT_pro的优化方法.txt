数据结构的优化：

原始版：邻接表，在头节点标注子句文字个数：
typedef struct LiteralNode{
    int data;
    struct LiteralNode* next;
}LiteralNode;

typedef struct ClauseNode{
    int num;//这个子句的文字个数
    struct LiteralNode* right;
    struct ClauseNode* down;
}ClauseNode;

优化版：类十字链表，用一个数组存储含有该文字的所有子句头指针：
typedef struct To_Clause{
    int sign;//判断是删的子句还是文字
    ClauseNode* target;//指向子句头节点
    struct To_Clause* next;
}To_Clause;

typedef struct Order_Table{
    To_Clause* right;
}Order_Table;//这个结构使用时都用数组定义
优化效果：在选择出变元进行简化时，可以直接定位变元所在的子句，且判断出其正负。、
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
回溯的优化：

原始版：利用愚蠢的COPY，然后free掉，不仅容易超内存，而且慢

优化版：利用另一个类十字链表结构中的数组结构和一个栈，这个数组储存用一个变元化简过程中删掉的子句和和含有该文字的头指针，栈存储每次选择的变元，回溯时只需要根据变元回溯
优化效果：对一个变元的化简操作时没有删除子句，回溯时只用把数组里的子句接回来就行了，没有了删除和创建的时间消耗，对空间的利用减少，回溯时会对子句相对位置进行重组（回溯的子句接在最上方），这对变元的选择起积极作用

优化_pro版：我们知道dpll过程是一个二叉树的遍历，而是否可以进行剪枝呢？显然是可以的。对于这颗二叉树的一个结点，他的值不会导致其一颗子树叶结点产生的冲突消失，及他的值不属于这些冲突子句的文字集合中，那么就不需要对他的另一颗子树进行遍历。于是我们定义一个Hash表，随递归存储叶节点子句的所有文字（这里又需要在clause中加一个left，内容与right相同，但是不会随递归变化），那么对于一个结点，如果在这次dpll中化简的文字都不在哈希表中，那么就不需要再递归他的另一颗子树。
优化效果：这种剪枝方法的效果受样例和变元选择策略影响，对于一些案例可以优化80%以上时间消耗。
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
变元选择：

通过几种策略的试验，选择了如下选择方法：

PickVar(){
	s=所有未满足子句中的最短子句的长度;
	对每一个变元v{
		x=v在所有长度为s的未满足子句中的总的出现次数;
		y=-v在所有长度为s的未满足子句中的总的出现次数;
		L=(x+1)*(y+1);
	}
	找到使L最大的变元;
	if(x>=y) return v;
	else return -v;
}
